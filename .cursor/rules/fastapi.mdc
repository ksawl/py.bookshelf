---
globs: *.py
alwaysApply: false
---
Ты эксперт по Python, FastAPI и созданию масштабируемых API.

Ключевые принципы
- Пиши краткие, технические ответы с точными примерами на Python.
- Используй классы где уместно, в остальном придерживайся функционального, декларативного программирования.
- Предпочитай итерацию и модуляризацию дублированию кода.
- Используй описательные имена переменных с вспомогательными глаголами (например, is_active, has_permission).
- Используй строчные буквы с подчеркиванием для директорий и файлов (например, routers/user_routes.py).
- Предпочитай именованный экспорт для роутов и утилитарных функций.
- Используй паттерн Get Object, Return Object (RORO).

Python/FastAPI
- Используй def для чистых функций и async def для асинхронных операций.
- Используй type hints для всех сигнатур функций. Предпочитай Pydantic модели простым словарям для валидации ввода.
- Структура файлов: экспортируемый роутер, подроуты, утилиты, статический контент, типы (модели, схемы).
- Избегай лишних фигурных скобок в условиях.
- Опускай фигурные скобки для однострочных операторов в условиях.
- Используй краткий, однострочный синтаксис для простых условий (например, if condition: do_something()).
- Всегда проверяй и удаляй не используемые импорты

Обработка ошибок и валидация
- Приоритизируй обработку ошибок и крайних случаев:
- Обрабатывай ошибки и крайние случаи в начале функций.
- Используй ранние возвраты для условий ошибок, чтобы избежать глубоко вложенных if операторов.
- Размещай счастливый путь в конце функции для улучшения читаемости.
- Избегай лишних else операторов; используй паттерн if-return вместо этого.
- Используй guard clauses для обработки предусловий и недопустимых состояний рано.
- Реализуй правильное логирование ошибок и отображай понятные сообщения об ошибках.
- Используй пользовательские типы ошибок или фабрики ошибок для согласованной обработки ошибок.

Зависимости
- FastAPI
- Pydantic v2
- Асинхронные библиотеки баз данных такие как asyncpg или aiomysql
- SQLAlchemy 2.0 (если используешь ORM функции)

Специфичные рекомендации для FastAPI
- Используй функциональные компоненты (простые функции) и Pydantic модели для валидации схем ввода и ответа.
- Используй декларативные определения роутов с четкими аннотациями типов возврата.
- Используй def для синхронных операций и async def для асинхронных.
- Минимизируй @app.on_event("startup") и @app.on_event("shutdown"); предпочитай lifecycle context managers для управления событиями запуска и завершения.
- Используй middleware для логирования, мониторинга ошибок и оптимизации производительности.
- Оптимизируй производительность используя async функции для I/O-bound задач, стратегии кеширования и ленивую загрузку.
- Используй HTTPException для ожидаемых ошибок и моделируй их как специфичные HTTP ответы.
- Используй middleware для обработки неожиданных ошибок, логирования и мониторинга ошибок.
- Используй Pydantic BaseModel для согласованной валидации I/O и схем ответов.

Оптимизация производительности
- Минимизируй блокирующий I/O; используй async операции для всех вызовов базы данных и внешних API запросов.
- Реализуй кеширование для статических и часто запрашиваемых данных используя инструменты как Redis или in-memory хранилища.
- Оптимизируй сериализацию и десериализацию данных с Pydantic.
- Используй техники ленивой загрузки для больших наборов данных и больших API ответов.

Базовые соглашения
1. Используй систему dependency injection FastAPI для управления состоянием и общими ресурсами.
2. Приоритизируй метрики производительности API (время ответа, задержка, пропускная способность).
3. Ограничь блокирующие операции в роутах:
- Предпочитай асинхронные и неблокирующие потоки.
- Используй выделенные асинхронные функции для операций с базой данных и внешними API.
- Четко структурируй роуты и зависимости для оптимизации читаемости и поддерживаемости.

Смотри документацию FastAPI для рекомендаций по моделям данных, path операциям и middleware.

Специфичные правила для данного проекта (Bookshelf API)
- Используй гибридный async/sync подход: async endpoints + asyncio.to_thread() для sync сервисов
- Создавай новые экземпляры сервисов для каждого запроса через dependency injection (не singleton)
- Для базы данных: AsyncDatabaseService для startup/shutdown, SyncDatabaseService для бизнес-логики
- Используй structlog для структурного логирования с LoggerMixin
- Предпочитай TypedDict для внутренних структур данных, BaseModel для API схем
- Background tasks используй для долгих операций (обработка файлов)
- Обрабатывай ошибки через factory функции (validation_http_error, not_found_http_error, internal_server_http_error)
- Используй SQLAlchemy 2.0+ синтаксис с select() и session patterns
- Для внешних сервисов (Pinecone, Ollama, LangChain) создавай отдельные сервисные классы
- Валидируй конфигурацию при старте через Settings.validate_runtime_dependencies()
- Используй namespace паттерн для изоляции данных в Pinecone (book_{book_id})
- Логируй операции с контекстом (book_id, filename, status) для трассировки